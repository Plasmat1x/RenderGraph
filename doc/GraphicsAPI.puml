@startuml GraphicsAPIInterfaces

package CoreInterfaces {
    interface IDisposable {
        + Dispose() : void
    }

    interface IGraphicsDevice extends IDisposable {
        + CreateCommandPool(type: CommandListType) : ICommandPool
        + CreateBuffer(size: long, usage: BufferUsage, memoryFlags: MemoryPropertyFlags) : IBuffer
        + CreateTexture(width: int, height: int, format: Format, usage: TextureUsage) : ITexture
        + CreateShaderModule(code: byte[], stage: ShaderStage) : IShaderModule
        + CreateGraphicsPipeline(description: GraphicsPipelineDescription) : IPipeline
        + Present() : void
    }

    interface ICommandPool extends IDisposable {
        + AllocateCommandList() : ICommandList
        + Reset() : void
        + FreeCommandList(list: ICommandList) : void
    }

    interface ICommandList extends IDisposable {
        + Begin() : void
        + End() : void
        + Reset() : void ' For resetting the list state, not the allocator
        + BeginRenderPass(renderPass: IRenderPass, framebuffer: IFramebuffer) : void
        + EndRenderPass() : void
        + BindPipeline(pipeline: IPipeline) : void
        + BindVertexBuffer(buffer: IBuffer, offset: long) : void
        + BindIndexBuffer(buffer: IBuffer, type: IndexType, offset: long) : void
        + SetViewport(x: float, y: float, width: float, height: float, minDepth: float, maxDepth: float) : void
        + SetScissor(x: int, y: int, width: int, height: int) : void
        + BindResources(pipeline: IPipeline, resourceSet: IResourceSet) : void
        + Draw(vertexCount: int, instanceCount: int, firstVertex: int, firstInstance: int) : void
        + DrawIndexed(indexCount: int, instanceCount: int, firstIndex: int, vertexOffset: int, firstInstance: int) : void
        + ResourceBarrier(resource: IResource, oldState: ResourceState, newState: ResourceState) : void
    }

    interface IBuffer extends IDisposable {
        + SetData<T>(data: T[], offset: long) : void
        + GetNativeHandle() : IntPtr
        + GetSize() : long
    }

    interface ITexture extends IDisposable {
        + SetData(data: byte[], mipLevel: int, arrayLayer: int) : void
        + GetNativeHandle() : IntPtr
        + GetWidth() : int
        + GetHeight() : int
        + GetFormat() : Format
    }

    interface IShaderModule extends IDisposable {
        + GetShaderStage() : ShaderStage
        + GetShaderResourceLayout() : ShaderResourceLayouts
    }

    interface IPipeline extends IDisposable {
        + GetPipelineLayoutInfo() : PipelineLayoutInfo
        + GetShaderModules() : IShaderModule[]
    }

    interface IResourceSet extends IDisposable {
    }

    interface IRenderPass extends IDisposable {
        + GetAttachments() : RenderPassAttachment[]
    }

    interface IFramebuffer extends IDisposable {
        + GetAttachments() : ITexture[]
    }

    class GraphicsPipelineDescription {
        + VertexShader : IShaderModule
        + FragmentShader : IShaderModule
        + VertexInput : VertexInputLayout
        + ResourceBindings : List<ResourceBindingDescription>
        + BlendState : BlendState
        + DepthStencilState : DepthStencilState
        + RasterizerState : RasterizerState
        + Topology : PrimitiveTopology
    }

    class VertexInputLayout {
        + Attributes : List<VertexAttribute>
    }

    class VertexAttribute {
        + Name : string
        + Format : Format
        + Offset : int
        + Binding : int
    }

    class ResourceBindingDescription {
        + Name : string
        + Type : ResourceType
        + Binding : int
        + Stage : ShaderStage
    }

    class ShaderResourceLayout {
        + Bindings : List<ResourceBindingDescription>
    }

    class PipelineLayoutInfo {
        + DescriptorSetLayouts : List<DescriptorSetLayoutDescription> ' If using Vulkan-like model
        + RootParameters : List<RootParameterDescription> ' If using DX12-like model
    }

    enum CommandListType 
    { 
        Graphics
        Compute
        Copy 
    }
    enum BufferUsage 
    { 
        VertexBuffer
        IndexBuffer
        UniformBuffer
        StorageBuffer 
    }
    enum TextureUsage 
    { 
        Sampled
        Attachment
        Storage 
    }
    enum Format 
    { 
        R8G8B8A8_UNorm
        D32_SFloat 
        
    }
    enum ShaderStage 
    { 
        Vertex
        Fragment
        Compute 
    }
    enum IndexType 
    { 
        UInt16
        UInt32 
    }
    enum ResourceType 
    { 
        UniformBuffer
        CombinedImageSampler
        Sampler
        SampledTexture
        StorageBuffer
        StorageTexture 
    }
}

package DirectX12Implementation {
    class Dx12GraphicsDevice implements IGraphicsDevice {
        - _d3d12Device : ID3D12Device
    }
    class Dx12CommandPool implements ICommandPool {
        - _d3d12CommandAllocators : ID3D12CommandAllocator[]
         
    }
    class Dx12CommandListWrapper implements ICommandList {
        - _d3d12CommandList : ID3D12GraphicsCommandList
         
    }
    class Dx12Buffer implements IBuffer {
        - _d3d12Resource : ID3D12Resource
         
    }
    class Dx12Texture implements ITexture {
        - _d3d12Resource : ID3D12Resource
        - _d3d12CpuDescriptorHandle : D3D12_CPU_DESCRIPTOR_HANDLE ' for SRV/RTV/DSV
         
    }
    class Dx12ShaderModule implements IShaderModule {
        - _byteCode : byte[] ' DXIL/DXBC
         
    }
    class Dx12Pipeline implements IPipeline {
        - _d3d12PipelineState : ID3D12PipelineState
        - _d3d12RootSignature : ID3D12RootSignature
         
    }
    class Dx12ResourceSet implements IResourceSet {
        - _d3d12DescriptorHeap : ID3D12DescriptorHeap
        - _cpuDescriptorHandle : D3D12_CPU_DESCRIPTOR_HANDLE
         
    }
    class Dx12RenderPass implements IRenderPass {
         
    }
    class Dx12Framebuffer implements IFramebuffer {
        - _rtvHandles : D3D12_CPU_DESCRIPTOR_HANDLE[]
        - _dsvHandle : D3D12_CPU_DESCRIPTOR_HANDLE
         
    }
}

package VulkanImplementation {
    class VulkanGraphicsDevice implements IGraphicsDevice {
        - _vkDevice : VkDevice
         
    }
    class VulkanCommandPool implements ICommandPool {
        - _vkCommandPool : VkCommandPool
         
    }
    class VulkanCommandListWrapper implements ICommandList {
        - _vkCommandBuffer : VkCommandBuffer
         
    }
    class VulkanBuffer implements IBuffer {
        - _vkBuffer : VkBuffer
        - _vkDeviceMemory : VkDeviceMemory
         
    }
    class VulkanTexture implements ITexture {
        - _vkImage : VkImage
        - _vkDeviceMemory : VkDeviceMemory
        - _vkImageView : VkImageView
         
    }
    class VulkanShaderModule implements IShaderModule {
        - _vkShaderModule : VkShaderModule
         
    }
    class VulkanPipeline implements IPipeline {
        - _vkPipeline : VkPipeline
        - _vkPipelineLayout : VkPipelineLayout
         
    }
    class VulkanResourceSet implements IResourceSet {
        - _vkDescriptorSet : VkDescriptorSet
         
    }
    class VulkanRenderPass implements IRenderPass {
        - _vkRenderPass : VkRenderPass
         
    }
    class VulkanFramebuffer implements IFramebuffer {
        - _vkFramebuffer : VkFramebuffer
         
    }
}

CoreInterfaces.IGraphicsDevice "1" --> "*" CoreInterfaces.ICommandPool : creates
CoreInterfaces.ICommandPool "1" --> "*" CoreInterfaces.ICommandList : allocates
CoreInterfaces.IGraphicsDevice "1" --> "*" CoreInterfaces.IBuffer : creates
CoreInterfaces.IGraphicsDevice "1" --> "*" CoreInterfaces.ITexture : creates
CoreInterfaces.IGraphicsDevice "1" --> "*" CoreInterfaces.IShaderModule : creates
CoreInterfaces.IGraphicsDevice "1" --> "*" CoreInterfaces.IPipeline : creates

CoreInterfaces.IPipeline "1" --> "*" CoreInterfaces.IShaderModule : uses
CoreInterfaces.ICommandList "1" --> "*" CoreInterfaces.IPipeline : binds
CoreInterfaces.ICommandList "1" --> "*" CoreInterfaces.IBuffer : binds
CoreInterfaces.ICommandList "1" --> "*" CoreInterfaces.IResourceSet : binds

CoreInterfaces.GraphicsPipelineDescription "1" --> "*" CoreInterfaces.IShaderModule : references
CoreInterfaces.GraphicsPipelineDescription "1" --> "*" CoreInterfaces.ResourceBindingDescription : describes
CoreInterfaces.IShaderModule "1" --> "1" CoreInterfaces.ShaderResourceLayout : provides info

CoreInterfaces.IRenderPass "1" --> "*" CoreInterfaces.IFramebuffer : compatible with
CoreInterfaces.ICommandList "1" --> "1" CoreInterfaces.IRenderPass : begins with
CoreInterfaces.ICommandList "1" --> "1" CoreInterfaces.IFramebuffer : begins with

Dx12GraphicsDevice ..|> IGraphicsDevice
VulkanGraphicsDevice ..|> IGraphicsDevice

Dx12CommandPool ..|> ICommandPool
VulkanCommandPool ..|> ICommandPool

Dx12CommandListWrapper ..|> ICommandList
VulkanCommandListWrapper ..|> ICommandList

Dx12Buffer ..|> IBuffer
VulkanBuffer ..|> IBuffer

Dx12Texture ..|> ITexture
VulkanTexture ..|> ITexture

Dx12ShaderModule ..|> IShaderModule
VulkanShaderModule ..|> IShaderModule

Dx12Pipeline ..|> IPipeline
VulkanPipeline ..|> IPipeline

Dx12ResourceSet ..|> IResourceSet
VulkanResourceSet ..|> IResourceSet

Dx12RenderPass ..|> IRenderPass
VulkanRenderPass ..|> IRenderPass

Dx12Framebuffer ..|> IFramebuffer
VulkanFramebuffer ..|> IFramebuffer

@enduml